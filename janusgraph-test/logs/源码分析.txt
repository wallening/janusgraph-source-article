复合索引 单属性 查询 源码分析

点id序解析
rowkey为64为long
janus：0 | count | partition | ID padding (if any) 
habse: partition |0 | count | ID padding


点qualifier解析
IDHandler.readRelationType(new ReadArrayBuffer(q)).typeId

点属性解析
通过调用以下方法自动解析habse数据
String vS = new StringSerializer().read(new ReadArrayBuffer(v));


边id解析
同点属性解析


边iqualifier解析


边属性解析


复合索引id解析
此方法是private，无法直接使用
IndexSerializer
	private StaticBuffer getIndexKey(CompositeIndexType index, Object[] values)
	



复合iqualifier解析
唯一索引：0
非唯一索引：0+vertex id

复合属性解析


// schema
JanusGraphSchemaCategory
EDGELABEL, PROPERTYKEY, VERTEXLABEL, GRAPHINDEX, TYPE_MODIFIER;

// 内置属性
SystemTypeManager.SYSTEM_TYPES_BY_NAME
	BaseKey.SchemaCategory				34
	BaseKey.SchemaDefinitionDesc		35
	BaseKey.SchemaDefinitionProperty	33
	BaseKey.SchemaName					32
	BaseKey.SchemaUpdateTime			36
	BaseKey.VertexExists				1

	BaseLabel.VertexLabelEdge
	BaseLabel.SchemaDefinitionEdge

	ImplicitKey.ID
	ImplicitKey.JANUSGRAPHID
	ImplicitKey.LABEL
	ImplicitKey.KEY
	ImplicitKey.VALUE
	ImplicitKey.ADJACENT_ID
	ImplicitKey.TIMESTAMP
	ImplicitKey.TTL
	ImplicitKey.VISIBILITY


EdgeSerializer 
	public RelationCache parseRelation(Entry data, boolean excludeProperties, TypeInspector tx)
	
CacheVertexProperty 

GraphCentricQueryBuilder
	// 通过复合索引查询
	public GraphCentricQuery constructQueryWithoutProfile(final ElementCategory resultType)
	

JanusGraphStep
	public JanusGraphStep(final GraphStep<S, E> originalStep)
	
IndexSerializer
	public MultiKeySliceQuery getQuery(final CompositeIndexType index, List<Object[]> values) 
	
	
	// 获取复合索引对应的Rowkey
	private StaticBuffer getIndexKey(CompositeIndexType index, Object[] values) 
		DEFAULT_OBJECT_BYTELEN = 30
		final DataOutput out = serializer.getDataOutput(8*DEFAULT_OBJECT_BYTELEN + 8);
		
		// index.getID() = 1545 （索引v1p1）
		// 将id使用压缩算法写入缓存
		VariableLong.writePositive(out, index.getID());
	
	
	
	
StringSerializer
	// 序列化复合索引 值
	// LONG_COMPRESSION_THRESHOLD = 16000 
	// 超长使用压缩算法CompressionType.GZIP
	// 如果
	public void write(WriteBuffer buffer, String attribute)
		// 判断每个字符在 0-127之间
		if (StringEncoding.isAsciiString(attribute)) 

VariableLong  好像没啥用
	// id序列化 offset=14 value=1545
	private static void writeUnsigned(WriteBuffer out, int offset, final long value)
	
	
	
	
// 复合索引
GraphCentricQueryBuilder
	public GraphCentricQuery constructQueryWithoutProfile(final ElementCategory resultType)
		337行
		jointQuery.add((CompositeIndexType)bestCandidate,
                            serializer.getQuery((CompositeIndexType)bestCandidate,(List<Object[]>)candidateSubCondition));
							
						


// 写数据
HbaseStoreManger
	// 序列化到hbase
	public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, StoreTransaction txh)

// habse查询
HBaseKeyColumnValueStore


// 复合索引查询过程
List<Vertex> list = client.traversal().V().hasLabel(v1).has(p1, val).toList();
// 通过属性名获取属性
StandardJanusGraph.retrieveSchemaByName
	// 获取propertyKeyVertex
	JanusGraphVertex v = Iterables.getOnlyElement(QueryUtil.getVertices(consistentTx, BaseKey.SchemaName, typeName), null);
	QueryUtil.getVertices
		vertices()
			// 复合索引Query
			GraphCentricQuery


vertex.keys()
	Element.keys()
		properties().forEachRemaining().hasNext()
			RelationConstructor.readRelation
				// 查询数据
				// SimpleVertexQueryProcessor
				iterator = data.iterator()
			.hasNext()
			.next()
				// CacheVertexProperty
				current = readRelation(vertex, iterator.next(),tx)
					// 属性id转换为long
					readRelation(data, true, tx)
						parseRelation(data, parseHeaderOnly, tx)
							// RelationTypeParse 
							RelationTypeParse typeAndDir = IDHandler.readRelationType(in);
								// 转换属性的id和属性类型
								long[] countPrefix = VariableLong.readPositiveWithPrefix(in, PREFIX_BIT_LEN);
								long typeId = countPrefix[0] >>> 1;
							
							// RelationTypeVertex
							def.multiplicity()
								// 获取janus schema相关
								// JanusGraphSchemaVertex
								getDefinition()
									// BaseKey  默认不可见的属性的 qualifier
			
			
			
			
			
			
			
			
			
			
SimpleVertexQueryProcessor
	public Iterator<Entry> iterator()
	private Iterator<Entry> getBasicIterator()
	public EntryList loadRelations(final SliceQuery query, final Retriever<SliceQuery, EntryList> lookup)
		// 执行查询 result赋值
		result = lookup.get(query);
	
RelationConstructor
	public static Iterable<JanusGraphRelation> readRelation(final InternalVertex vertex, final Iterable<Entry> data, final StandardJanusGraphTx tx)



VertexCentricQueryBuilder
	protected<Q> Q execute(RelationCategory returnType, ResultConstructor<Q> resultConstructor)
	
	
vertex.property(key)  Vertex->AbstractVertex->VertexCentricQueryBuilder
	protected<Q> Q execute(RelationCategory returnType, ResultConstructor<Q> resultConstructor)
	
	













